import{k as c,l as S,C as h}from"./index.b1426589.js";const s=c("life-count",0),i=c("max-life-count",0),u=c("temp-life-count",0),m=S("lifecount",()=>{function l(e){s.value=e,i.value=e}function o(e){u.value=e}function a(){s.value<i.value&&(s.value=s.value+1)}function n(){if(u.value>0){u.value=u.value-1;return}s.value>0&&(s.value=s.value-1)}function t(){s.value=i.value}return{lifeCount:s,maxLifeCount:i,tempLifeCount:u,setLife:l,setTempLife:o,incrementLife:a,substractLife:n,rest:t}}),v=c("character",""),C=S("character",()=>{function l(a){v.value=a}function o(a){return v.value===a}return{character:v,setCharacter:l,isCharacterInStore:o}}),r=c("ability-list",{}),L=S("abilitylist",()=>{function l(t,e){r.value[t]={maxSlots:e,slots:new Array(e).fill(!1)}}function o(t){const e={};console.log(t),Object.keys(t).forEach(f=>{e[f]={maxSlots:t[f],slots:new Array(t[f]).fill(!1)}}),console.log(e),r.value=e}function a(t,e){e<r.value[t].maxSlots&&(r.value[t].slots[e]=!r.value[t].slots[e])}function n(){Object.keys(r.value).forEach(t=>{r.value[t].slots=new Array(r.value[t].maxSlots).fill(!1)})}return{abilityList:r,addAbility:l,toggleSlot:a,resetAbilities:n,setAbilities:o}});class y{static setStoreDataFromCharacter(o){const a=m(),n=C(),t=L(),e=h.fromEncode(o);return n.isCharacterInStore(e.name)||(n.setCharacter(e.name),a.setLife(e.life),t.setAbilities(e.abilityList)),e}}export{y as S,C as a,L as b,m as u};
